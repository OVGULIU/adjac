! -*-f90-*-
!
! adjac: Automatic Differentiation for generating Jacobians.
!

! Copyright (c) 2014, Pauli Virtanen <pav@iki.fi>
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions
! are met:
!
! 1. Redistributions of source code must retain the above copyright
! notice, this list of conditions and the following disclaimer.
!
! 2. Redistributions in binary form must reproduce the above copyright
! notice, this list of conditions and the following disclaimer in the
! documentation and/or other materials provided with the distribution.
!
! 3. Neither the name of the copyright holder nor the names of its
! contributors may be used to endorse or promote products derived from
! this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
! FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
! COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
! INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
! BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
! LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
! ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
! POSSIBILITY OF SUCH DAMAGE.

module adjac
  private

{{default USE_ALLOCATABLE = False}}

  ! NOTE: we would like to use derived type finalizers for memory
  ! deallocation.  However, as of 2015-03-12, these are not fully
  ! implemented in gfortran, and will not be called e.g. on function
  ! returns that the code here extensively relies on.

  type, public :: adjac_double
     double precision :: value, vmul
     integer :: n = 0
{{if USE_ALLOCATABLE}}
     double precision, dimension(:), allocatable :: v
     integer, dimension(:), allocatable :: i
{{else}}
     integer :: j = 1
{{endif}}
  end type adjac_double

  type, public :: adjac_complexan
     double complex :: value, vmul
     integer :: n = 0
{{if USE_ALLOCATABLE}}
     double complex, dimension(:), allocatable :: v
     integer, dimension(:), allocatable :: i
{{else}}
     integer :: j = 1
{{endif}}
  end type adjac_complexan

  type, public :: adjac_complex
     type(adjac_double) :: re, im
  end type adjac_complex

  logical :: jac_product_mode = .false.

{{if not USE_ALLOCATABLE}}
  integer :: free_a = 1, free_q = 1
  integer, dimension(:), allocatable :: imem_a, imem_q
  double precision, dimension(:), allocatable :: vmem_a
  double complex, dimension(:), allocatable :: vmem_q
{{endif}}

{{if USE_ALLOCATABLE}}
  {{default pure = "pure"}}
  {{default pure_elemental = "pure elemental"}}
{{else}}
  {{default pure = ""}}
  {{default pure_elemental = ""}}
{{endif}}

{{py:

def binops(name, use_allocatable):
    chrs = ['i', 'd', 'z']
    ops = ['aa', 'bb', 'qq', 'ab', 'ba']
    for c in chrs:
        ops += ['a'+c, 'b'+c, 'q'+c, c+'a', c+'b', c+'q']
    oldops = list(ops)
    if not use_allocatable:
        for suf in ['_1', '_01', '_10',
                    '_2', '_02', '_20',
                    '_3', '_03', '_30',
                    '_4', '_04', '_40']:
            ops.extend([x + suf for x in oldops])
    s = "\n".join("     module procedure " + name + "_" + op for op in ops)
    return s.lstrip()

def elemental_versions(name, rtype, ops=None):
    if ops is None:
        chrs = ['i', 'd', 'z']
        ops = ['aa', 'bb', 'qq', 'ab', 'ba']
        for c in chrs:
            ops += ['a'+c, 'b'+c, 'q'+c, c+'a', c+'b', c+'q']

    binop_code = """
    function {name}_{op}_1(a, b) result(c)
      implicit none
      {typea}, dimension(:), intent(in) :: a
      {typeb}, dimension(size(a)), intent(in) :: b
      {typec}, dimension(size(a)) :: c
      integer :: i
      do i = 1, size(a)
        c(i) = {name}_{op}(a(i), b(i))
      end do
    end function {name}_{op}_1
    function {name}_{op}_01(a, b) result(c)
      implicit none
      {typea}, intent(in) :: a
      {typeb}, dimension(:), intent(in) :: b
      {typec}, dimension(size(b)) :: c
      integer :: i
      do i = 1, size(b)
        c(i) = {name}_{op}(a, b(i))
      end do
    end function {name}_{op}_01
    function {name}_{op}_10(a, b) result(c)
      implicit none
      {typea}, dimension(:), intent(in) :: a
      {typeb}, intent(in) :: b
      {typec}, dimension(size(a)) :: c
      integer :: i
      do i = 1, size(a)
        c(i) = {name}_{op}(a(i), b)
      end do
    end function {name}_{op}_10

    function {name}_{op}_2(a, b) result(c)
      implicit none
      {typea}, dimension(:,:), intent(in) :: a
      {typeb}, dimension(size(a,1),size(a,2)), intent(in) :: b
      {typec}, dimension(size(a,1),size(a,2)) :: c
      integer :: i, j
      do j = 1, size(a,2)
        do i = 1, size(a,1)
          c(i,j) = {name}_{op}(a(i,j), b(i,j))
        end do
      end do
    end function {name}_{op}_2
    function {name}_{op}_02(a, b) result(c)
      implicit none
      {typea}, intent(in) :: a
      {typeb}, dimension(:,:), intent(in) :: b
      {typec}, dimension(size(b,1),size(b,2)) :: c
      integer :: i, j
      do j = 1, size(b,2)
        do i = 1, size(b,1)
          c(i,j) = {name}_{op}(a, b(i,j))
        end do
      end do
    end function {name}_{op}_02
    function {name}_{op}_20(a, b) result(c)
      implicit none
      {typea}, dimension(:,:), intent(in) :: a
      {typeb}, intent(in) :: b
      {typec}, dimension(size(a,1),size(a,2)) :: c
      integer :: i, j
      do j = 1, size(a,2)
        do i = 1, size(a,1)
          c(i,j) = {name}_{op}(a(i,j), b)
        end do
      end do
    end function {name}_{op}_20

    function {name}_{op}_3(a, b) result(c)
      implicit none
      {typea}, dimension(:,:,:), intent(in) :: a
      {typeb}, dimension(size(a,1),size(a,2),size(a,3)), intent(in) :: b
      {typec}, dimension(size(a,1),size(a,2),size(a,3)) :: c
      integer :: i, j, k
      do k = 1, size(a,3)
        do j = 1, size(a,2)
          do i = 1, size(a,1)
            c(i,j,k) = {name}_{op}(a(i,j,k), b(i,j,k))
          end do
        end do
      end do
    end function {name}_{op}_3
    function {name}_{op}_03(a, b) result(c)
      implicit none
      {typea}, intent(in) :: a
      {typeb}, dimension(:,:,:), intent(in) :: b
      {typec}, dimension(size(b,1),size(b,2),size(b,3)) :: c
      integer :: i, j, k
      do k = 1, size(b,3)
        do j = 1, size(b,2)
          do i = 1, size(b,1)
            c(i,j,k) = {name}_{op}(a, b(i,j,k))
          end do
        end do
      end do
    end function {name}_{op}_03
    function {name}_{op}_30(a, b) result(c)
      implicit none
      {typea}, dimension(:,:,:), intent(in) :: a
      {typeb}, intent(in) :: b
      {typec}, dimension(size(a,1),size(a,2),size(a,3)) :: c
      integer :: i, j, k
      do k = 1, size(a,3)
        do j = 1, size(a,2)
          do i = 1, size(a,1)
            c(i,j,k) = {name}_{op}(a(i,j,k), b)
          end do
        end do
      end do
    end function {name}_{op}_30

    function {name}_{op}_4(a, b) result(c)
      implicit none
      {typea}, dimension(:,:,:,:), intent(in) :: a
      {typeb}, dimension(size(a,1),size(a,2),size(a,3),size(a,4)), intent(in) :: b
      {typec}, dimension(size(a,1),size(a,2),size(a,3),size(a,4)) :: c
      integer :: i, j, k, l
      do l = 1, size(a,4)
        do k = 1, size(a,3)
          do j = 1, size(a,2)
            do i = 1, size(a,1)
              c(i,j,k,l) = {name}_{op}(a(i,j,k,l), b(i,j,k,l))
            end do
          end do
        end do
      end do
    end function {name}_{op}_4
    function {name}_{op}_04(a, b) result(c)
      implicit none
      {typea}, intent(in) :: a
      {typeb}, dimension(:,:,:,:), intent(in) :: b
      {typec}, dimension(size(b,1),size(b,2),size(b,3),size(b,4)) :: c
      integer :: i, j, k, l
      do l = 1, size(b,4)
        do k = 1, size(b,3)
          do j = 1, size(b,2)
            do i = 1, size(b,1)
              c(i,j,k,l) = {name}_{op}(a, b(i,j,k,l))
            end do
          end do
        end do
      end do
    end function {name}_{op}_04
    function {name}_{op}_40(a, b) result(c)
      implicit none
      {typea}, dimension(:,:,:,:), intent(in) :: a
      {typeb}, intent(in) :: b
      {typec}, dimension(size(a,1),size(a,2),size(a,3),size(a,4)) :: c
      integer :: i, j, k, l
      do l = 1, size(a,4)
        do k = 1, size(a,3)
          do j = 1, size(a,2)
            do i = 1, size(a,1)
              c(i,j,k,l) = {name}_{op}(a(i,j,k,l), b)
            end do
          end do
        end do
      end do
    end function {name}_{op}_40
    """

    unop_code = """
    function {name}_{op}_1(a) result(c)
      implicit none
      {typea}, dimension(:), intent(in) :: a
      {typec}, dimension(size(a)) :: c
      integer :: i
      do i = 1, size(a)
        c(i) = {name}_{op}(a(i))
      end do
    end function {name}_{op}_1
    function {name}_{op}_2(a) result(c)
      implicit none
      {typea}, dimension(:,:), intent(in) :: a
      {typec}, dimension(size(a,1),size(a,2)) :: c
      integer :: i, j
      do j = 1, size(a,2)
        do i = 1, size(a,1)
          c(i,j) = {name}_{op}(a(i,j))
        end do
      end do
    end function {name}_{op}_2
    function {name}_{op}_3(a) result(c)
      implicit none
      {typea}, dimension(:,:,:), intent(in) :: a
      {typec}, dimension(size(a,1),size(a,2),size(a,3)) :: c
      integer :: i, j, k
      do k = 1, size(a,3)
        do j = 1, size(a,2)
          do i = 1, size(a,1)
            c(i,j,k) = {name}_{op}(a(i,j,k))
          end do
        end do
      end do
    end function {name}_{op}_3
    function {name}_{op}_4(a) result(c)
      implicit none
      {typea}, dimension(:,:,:,:), intent(in) :: a
      {typec}, dimension(size(a,1),size(a,2),size(a,3),size(a,4)) :: c
      integer :: i, j, k, l
      do l = 1, size(a,4)
        do k = 1, size(a,3)
          do j = 1, size(a,2)
            do i = 1, size(a,1)
              c(i,j,k,l) = {name}_{op}(a(i,j,k,l))
            end do
          end do
        end do
      end do
    end function {name}_{op}_4
    """

    assign_code = """
    subroutine {name}_{op}_1(c, a)
      implicit none
      {typea}, dimension(:), intent(in) :: a
      {typec}, dimension(:), intent(out) :: c
      integer :: i
      do i = 1, size(c)
        call {name}_{op}(c(i), a(i))
      end do
    end subroutine {name}_{op}_1
    subroutine {name}_{op}_10(c, a)
      implicit none
      {typea}, intent(in) :: a
      {typec}, dimension(:), intent(out) :: c
      integer :: i
      do i = 1, size(c)
        call {name}_{op}(c(i), a)
      end do
    end subroutine {name}_{op}_10
    subroutine {name}_{op}_2(c, a)
      implicit none
      {typea}, dimension(:,:), intent(in) :: a
      {typec}, dimension(size(a,1),size(a,2)), intent(out) :: c
      integer :: i, j
      do j = 1, size(a,2)
        do i = 1, size(a,1)
          call {name}_{op}(c(i,j), a(i,j))
        end do
      end do
    end subroutine {name}_{op}_2
    subroutine {name}_{op}_20(c, a)
      implicit none
      {typea}, intent(in) :: a
      {typec}, dimension(:,:), intent(out) :: c
      integer :: i, j
      do j = 1, size(c,2)
        do i = 1, size(c,1)
          call {name}_{op}(c(i,j), a)
        end do
      end do
    end subroutine {name}_{op}_20
    subroutine {name}_{op}_3(c, a)
      implicit none
      {typea}, dimension(:,:,:), intent(in) :: a
      {typec}, dimension(:,:,:), intent(out) :: c
      integer :: i, j, k
      do k = 1, size(c,3)
        do j = 1, size(c,2)
          do i = 1, size(c,1)
            call {name}_{op}(c(i,j,k), a(i,j,k))
          end do
        end do
      end do
    end subroutine {name}_{op}_3
    subroutine {name}_{op}_30(c, a)
      implicit none
      {typea}, intent(in) :: a
      {typec}, dimension(:,:,:), intent(out) :: c
      integer :: i, j, k
      do k = 1, size(c,3)
        do j = 1, size(c,2)
          do i = 1, size(c,1)
            call {name}_{op}(c(i,j,k), a)
          end do
        end do
      end do
    end subroutine {name}_{op}_30
    subroutine {name}_{op}_4(c, a)
      implicit none
      {typea}, dimension(:,:,:,:), intent(in) :: a
      {typec}, dimension(:,:,:,:), intent(out) :: c
      integer :: i, j, k, l
      do l = 1, size(c,4)
        do k = 1, size(c,3)
          do j = 1, size(c,2)
            do i = 1, size(c,1)
              call {name}_{op}(c(i,j,k,l), a(i,j,k,l))
            end do
          end do
        end do
      end do
    end subroutine {name}_{op}_4
    subroutine {name}_{op}_40(c, a)
      implicit none
      {typea}, intent(in) :: a
      {typec}, dimension(:,:,:,:), intent(out) :: c
      integer :: i, j, k, l
      do l = 1, size(c,4)
        do k = 1, size(c,3)
          do j = 1, size(c,2)
            do i = 1, size(c,1)
              call {name}_{op}(c(i,j,k,l), a)
            end do
          end do
        end do
      end do
    end subroutine {name}_{op}_40
    """

    base_code = {'binop': binop_code, 'unop': unop_code, 'assign': assign_code}[rtype]
    types = {'a': 'type(adjac_double)', 
             'b': 'type(adjac_complex)',
             'q': 'type(adjac_complexan)',
             'i': 'integer',
             'd': 'double precision',
             'z': 'double complex'}

    s = ""
    typeb = ""
    for op in ops:
        if rtype == 'binop':
            typea = types[op[0]]
            typeb = types[op[1]]
            typec = typea if op[0] in 'abq' else typeb
            if typec == 'type(adjac_double)' and ('z' in op or 'b' in op): 
                typec = 'type(adjac_complex)'
        elif rtype == 'assign':
            typec = types[op[0]]
            typea = types[op[1]]
        else:
            typea = types[op[0]]
            typec = typea
        s += base_code.format(name=name, op=op, typea=typea, typeb=typeb, typec=typec)
    return s
}}

  public assignment(=)
  interface assignment(=)
     module procedure assign_ai, assign_ad
     module procedure assign_bi, assign_bd, assign_bz, assign_ba
     module procedure assign_qi, assign_qd, assign_qz

{{if not USE_ALLOCATABLE}}
     module procedure assign_ai_1, assign_ad_1
     module procedure assign_bi_1, assign_bd_1, assign_bz_1, assign_ba_1
     module procedure assign_qi_1, assign_qd_1, assign_qz_1

     module procedure assign_ai_10, assign_ad_10
     module procedure assign_bi_10, assign_bd_10, assign_bz_10, assign_ba_10
     module procedure assign_qi_10, assign_qd_10, assign_qz_10

     module procedure assign_ai_2, assign_ad_2
     module procedure assign_bi_2, assign_bd_2, assign_bz_2, assign_ba_2
     module procedure assign_qi_2, assign_qd_2, assign_qz_2

     module procedure assign_ai_20, assign_ad_20
     module procedure assign_bi_20, assign_bd_20, assign_bz_20, assign_ba_20
     module procedure assign_qi_20, assign_qd_20, assign_qz_20

     module procedure assign_ai_3, assign_ad_3
     module procedure assign_bi_3, assign_bd_3, assign_bz_3, assign_ba_3
     module procedure assign_qi_3, assign_qd_3, assign_qz_3

     module procedure assign_ai_30, assign_ad_30
     module procedure assign_bi_30, assign_bd_30, assign_bz_30, assign_ba_30
     module procedure assign_qi_30, assign_qd_30, assign_qz_30

     module procedure assign_ai_4, assign_ad_4
     module procedure assign_bi_4, assign_bd_4, assign_bz_4, assign_ba_4
     module procedure assign_qi_4, assign_qd_4, assign_qz_4

     module procedure assign_ai_40, assign_ad_40
     module procedure assign_bi_40, assign_bd_40, assign_bz_40, assign_ba_40
     module procedure assign_qi_40, assign_qd_40, assign_qz_40
{{endif}}
  end interface

  public operator(+)
  interface operator(+)
     {{binops("add", USE_ALLOCATABLE)}}
     module procedure pos_a, pos_b, pos_q
{{if not USE_ALLOCATABLE}}
     module procedure pos_a_1, pos_b_1, pos_q_1
     module procedure pos_a_2, pos_b_2, pos_q_2
     module procedure pos_a_3, pos_b_3, pos_q_3
     module procedure pos_a_4, pos_b_4, pos_q_4
{{endif}}
  end interface

  public operator(-)
  interface operator(-)
     {{binops("sub", USE_ALLOCATABLE)}}
     module procedure neg_a, neg_b, neg_q
{{if not USE_ALLOCATABLE}}
     module procedure neg_a_1, neg_b_1, neg_q_1
     module procedure neg_a_2, neg_b_2, neg_q_2
     module procedure neg_a_3, neg_b_3, neg_q_3
     module procedure neg_a_4, neg_b_4, neg_q_4
{{endif}}
  end interface

  public operator(*)
  interface operator(*)
     {{binops("mul", USE_ALLOCATABLE)}}
  end interface operator(*)

  public operator(/)
  interface operator(/)
     {{binops("div", USE_ALLOCATABLE)}}
  end interface operator(/)

  public operator(**)
  interface operator(**)
     module procedure pow_ai, pow_ad, pow_qi, pow_qd, pow_qz
{{if not USE_ALLOCATABLE}}
     module procedure pow_ai_1, pow_ad_1, pow_qi_1, pow_qd_1, pow_qz_1
     module procedure pow_ai_2, pow_ad_2, pow_qi_2, pow_qd_2, pow_qz_2
     module procedure pow_ai_3, pow_ad_3, pow_qi_3, pow_qd_3, pow_qz_3
     module procedure pow_ai_4, pow_ad_4, pow_qi_4, pow_qd_4, pow_qz_4

     module procedure pow_ai_10, pow_ad_10, pow_qi_10, pow_qd_10, pow_qz_10
     module procedure pow_ai_20, pow_ad_20, pow_qi_20, pow_qd_20, pow_qz_20
     module procedure pow_ai_30, pow_ad_30, pow_qi_30, pow_qd_30, pow_qz_30
     module procedure pow_ai_40, pow_ad_40, pow_qi_40, pow_qd_40, pow_qz_40

     module procedure pow_ai_01, pow_ad_01, pow_qi_01, pow_qd_01, pow_qz_01
     module procedure pow_ai_02, pow_ad_02, pow_qi_02, pow_qd_02, pow_qz_02
     module procedure pow_ai_03, pow_ad_03, pow_qi_03, pow_qd_03, pow_qz_03
     module procedure pow_ai_04, pow_ad_04, pow_qi_04, pow_qd_04, pow_qz_04
{{endif}}
  end interface operator(**)

  public matmul
  interface matmul
     module procedure matmul_aa, matmul_ai, matmul_ia, matmul_ad, matmul_da
     module procedure matmul_bb, matmul_bz, matmul_zb
     module procedure matmul_qq, matmul_qi, matmul_iq, matmul_qd, matmul_dq, matmul_qz, matmul_zq
  end interface matmul

  public dble
  interface dble
     module procedure dble_a, dble_b
{{if not USE_ALLOCATABLE}}
     module procedure dble_a_1, dble_b_1
     module procedure dble_a_2, dble_b_2
     module procedure dble_a_3, dble_b_3
     module procedure dble_a_4, dble_b_4
{{endif}}
  end interface dble

  public aimag
  interface aimag
     module procedure aimag_b
{{if not USE_ALLOCATABLE}}
     module procedure aimag_b_1
     module procedure aimag_b_2
     module procedure aimag_b_3
     module procedure aimag_b_4
{{endif}}
  end interface aimag

  public conjg
  interface conjg
     module procedure conjg_b
{{if not USE_ALLOCATABLE}}
     module procedure conjg_b_1
     module procedure conjg_b_2
     module procedure conjg_b_3
     module procedure conjg_b_4
{{endif}}
  end interface conjg

  public exp
  interface exp
     module procedure exp_a, exp_b, exp_q
{{if not USE_ALLOCATABLE}}
     module procedure exp_a_1, exp_b_1, exp_q_1
     module procedure exp_a_2, exp_b_2, exp_q_2
     module procedure exp_a_3, exp_b_3, exp_q_3
     module procedure exp_a_4, exp_b_4, exp_q_4
{{endif}}
  end interface exp

  public sin
  interface sin
     module procedure sin_a, sin_b, sin_q
{{if not USE_ALLOCATABLE}}
     module procedure sin_a_1, sin_b_1, sin_q_1
     module procedure sin_a_2, sin_b_2, sin_q_2
     module procedure sin_a_3, sin_b_3, sin_q_3
     module procedure sin_a_4, sin_b_4, sin_q_4
{{endif}}
  end interface sin

  public cos
  interface cos
     module procedure cos_a, cos_b, cos_q
{{if not USE_ALLOCATABLE}}
     module procedure cos_a_1, cos_b_1, cos_q_1
     module procedure cos_a_2, cos_b_2, cos_q_2
     module procedure cos_a_3, cos_b_3, cos_q_3
     module procedure cos_a_4, cos_b_4, cos_q_4
{{endif}}
  end interface cos

  public log
  interface log
     module procedure log_a, log_b, log_q
{{if not USE_ALLOCATABLE}}
     module procedure log_a_1, log_b_1, log_q_1
     module procedure log_a_2, log_b_2, log_q_2
     module procedure log_a_3, log_b_3, log_q_3
     module procedure log_a_4, log_b_4, log_q_4
{{endif}}
  end interface log

  interface adjac_set_independent
     module procedure set_independent_a, set_independent_q
     module procedure set_independent_many_a, set_independent_many_q
  end interface adjac_set_independent

  interface sum_taylor
     module procedure sum_taylor_a, sum_taylor_q
  end interface sum_taylor

  interface adjac_get_value
     module procedure get_value_one_a, get_value_one_q
     module procedure get_value_many_a, get_value_many_q
  end interface adjac_get_value

  interface adjac_get_dense_jacobian
     module procedure get_dense_jacobian_a, get_dense_jacobian_q
  end interface adjac_get_dense_jacobian

  interface adjac_get_csr_jacobian
     module procedure get_csr_jacobian_a, get_csr_jacobian_q
  end interface adjac_get_csr_jacobian

  interface adjac_get_coo_jacobian
     module procedure get_coo_jacobian_a, get_coo_jacobian_q
  end interface adjac_get_coo_jacobian

  interface adjac_get_nnz
     module procedure get_nnz_a, get_nnz_q
  end interface adjac_get_nnz

  public adjac_set_independent, adjac_get_value, &
       adjac_get_dense_jacobian, adjac_get_csr_jacobian, &
       adjac_get_coo_jacobian, adjac_get_nnz, &
       adjac_reset, adjac_free

contains

  subroutine fatal_error(msg)
    implicit none
    character(len=*), intent(in) :: msg
    write(*,*) 'adjac: error: ', trim(msg)
    stop
  end subroutine fatal_error

  subroutine adjac_reset(product_mode)
    implicit none
    logical, optional, intent(in) :: product_mode

    if (present(product_mode)) then
       jac_product_mode = product_mode
    end if

{{if not USE_ALLOCATABLE}}
    free_a = 1
    free_q = 1

    if (jac_product_mode) then
       return
    end if

    if (.not. allocated(imem_a)) then
       allocate(imem_a(100), vmem_a(100))
    end if
    if (.not. allocated(imem_q)) then
       allocate(imem_q(100), vmem_q(100))
    end if
{{endif}}
  end subroutine adjac_reset

  subroutine adjac_free()
    implicit none
{{if not USE_ALLOCATABLE}}
    free_a = 1
    free_q = 1
    if (allocated(imem_a)) then
       deallocate(imem_a)
       deallocate(vmem_a)
    end if
    if (allocated(imem_q)) then
       deallocate(imem_q)
       deallocate(vmem_q)
    end if
{{endif}}
  end subroutine adjac_free

{{for TYPE, FTYPE, CHR, CAST, FTYPES2 in [('adjac_double', 'double precision', 'a', 'dble', [('integer', 'i'),
                                                                                             ('double precision', 'd')]), 
                                          ('adjac_complexan', 'double complex', 'q', 'dcmplx', [('integer', 'i'),
                                                                                                ('double precision', 'd'), 
                                                                                                ('double complex', 'z')])]}}

  {{pure}} subroutine alloc_mem_{{CHR}}(x, n)
    implicit none
    type({{TYPE}}), intent(inout) :: x
    integer, intent(in) :: n

    integer, dimension(:), allocatable :: itmp
    {{FTYPE}}, dimension(:), allocatable :: tmp
    integer :: sz

    if (jac_product_mode) then
       return
    end if

{{if USE_ALLOCATABLE}}
    x%n = n
    allocate(x%i(n), x%v(n))
{{else}}
    if (.not.allocated(imem_{{CHR}})) then
       sz = 0
    else
       sz = size(imem_{{CHR}})
    end if

    if (sz < free_{{CHR}} + n) then
       ! Enlarge work space
       sz = sz + free_{{CHR}} + n
       allocate(itmp(sz), tmp(sz))
       itmp(1:size(imem_{{CHR}})) = imem_{{CHR}}(:)
       tmp(1:size(vmem_{{CHR}})) = vmem_{{CHR}}(:)
       call move_alloc(itmp, imem_{{CHR}})
       call move_alloc(tmp, vmem_{{CHR}})
    end if

    x%j = free_{{CHR}}
    x%n = n
    free_{{CHR}} = free_{{CHR}} + n
{{endif}}
  end subroutine alloc_mem_{{CHR}}

  {{pure}} subroutine link_mem_{{CHR}}(dst, src)
    implicit none
    type({{TYPE}}), intent(inout) :: dst
    type({{TYPE}}), intent(in) :: src
{{if USE_ALLOCATABLE}}
    dst%n = src%n
    if (src%n > 0) then
       dst%v = src%v
       dst%i = src%i
    end if
{{else}}
    dst%n = src%n
    dst%j = src%j
{{endif}}
  end subroutine link_mem_{{CHR}}

  {{pure}} subroutine free_mem_{{CHR}}(x)
    implicit none
    type({{TYPE}}), intent(inout) :: x
{{if USE_ALLOCATABLE}}
    if (x%n > 0) then
       deallocate(x%v)
       deallocate(x%i)
    end if
    x%n = 0
{{else}}
    x%j = 1
    x%n = 0
{{endif}}
  end subroutine free_mem_{{CHR}}

  subroutine set_independent_{{CHR}}(x, xval, j, dx)
    implicit none
    type({{TYPE}}), intent(out) :: x
    {{FTYPE}}, intent(in) :: xval
    {{FTYPE}}, optional, intent(in) :: dx
    integer, intent(in) :: j

    x%value = xval
    if (jac_product_mode) then
       if (.not.present(dx)) then
          call fatal_error('no dx given to adjac_set_independent when jacobian product mode is active')
       end if
       x%vmul = dx
    else
       x%vmul = 1
       call alloc_mem_{{CHR}}(x, 1)
{{if USE_ALLOCATABLE}}
       x%v(1) = 1
       x%i(1) = j
{{else}}
       imem_{{CHR}}(x%j) = j
       vmem_{{CHR}}(x%j) = 1
{{endif}}
    end if
  end subroutine set_independent_{{CHR}}

  subroutine set_independent_many_{{CHR}}(x, xval, dx)
    implicit none
    type({{TYPE}}), dimension(:), intent(inout) :: x
    {{FTYPE}}, dimension(size(x)), intent(in) :: xval
    {{FTYPE}}, dimension(size(x)), optional, intent(in) :: dx

    integer :: j

    if (present(dx)) then
       do j = 1, size(x,1)
          call set_independent_{{CHR}}(x(j), xval(j), j, dx(j))
       end do
    else
       do j = 1, size(x,1)
          call set_independent_{{CHR}}(x(j), xval(j), j)
       end do
    end if
  end subroutine set_independent_many_{{CHR}}

  subroutine get_value_one_{{CHR}}(y, val, dy)
    implicit none
    type({{TYPE}}), intent(in) :: y
    {{FTYPE}}, intent(out) :: val
    {{FTYPE}}, optional, intent(out) :: dy
    val = y%value
    if (present(dy)) then
       if (.not. jac_product_mode) then
          call fatal_error('call to adjac_get_value with dy when jacobian product mode is not active')
       end if
       dy = y%vmul
    end if
  end subroutine get_value_one_{{CHR}}

  subroutine get_value_many_{{CHR}}(y, val, dy)
    implicit none
    type({{TYPE}}), dimension(:), intent(in) :: y
    {{FTYPE}}, dimension(size(y,1)), intent(out) :: val
    {{FTYPE}}, dimension(size(y,1)), optional, intent(out) :: dy
    integer :: j
    do j = 1, size(val,1)
       val(j) = y(j)%value
    end do
    if (present(dy)) then
       if (.not. jac_product_mode) then
          call fatal_error('call to adjac_get_value with dy when jacobian product mode is not active')
       end if
       do j = 1, size(val,1)
          dy(j) = y(j)%vmul
       end do
    end if
  end subroutine get_value_many_{{CHR}}

  function get_nnz_{{CHR}}(y) result(nnz)
    type({{TYPE}}), dimension(:), intent(in) :: y
    integer :: nnz
    nnz = 0
    do i = 1, size(y,1)
       nnz = nnz + y(i)%n
    end do
  end function get_nnz_{{CHR}}

  subroutine get_dense_jacobian_{{CHR}}(y, jac_dense)
    implicit none
    type({{TYPE}}), dimension(:), intent(inout) :: y
    {{FTYPE}}, dimension(:,:), intent(out) :: jac_dense

    integer :: i, p

    if (jac_product_mode) then
       call fatal_error('call to adjac_get_dense_jacobian when jacobian product mode is active')
    end if

    jac_dense = 0

    do i = 1, size(y,1)
       do p = 1, y(i)%n
{{if USE_ALLOCATABLE}}
          jac_dense(i, y(i)%i(p)) = jac_dense(i, y(i)%i(p)) &
               + y(i)%vmul * y(i)%v(p)
{{else}}
          jac_dense(i, imem_{{CHR}}(y(i)%j + p - 1)) = jac_dense(i, imem_{{CHR}}(y(i)%j + p - 1)) &
               + y(i)%vmul * vmem_{{CHR}}(y(i)%j + p - 1)
{{endif}}
       end do
    end do
  end subroutine get_dense_jacobian_{{CHR}}

  subroutine get_coo_jacobian_{{CHR}}(y, jac_val, jac_i, jac_j)
    implicit none
    type({{TYPE}}), dimension(:), intent(inout) :: y
    {{FTYPE}}, dimension(:), intent(out) :: jac_val
    integer, dimension(:), intent(out) :: jac_i, jac_j

    integer :: i, k

    if (jac_product_mode) then
       call fatal_error('call to adjac_get_coo_jacobian when jacobian product mode is active')
    end if

    k = 1
    do i = 1, size(y,1)
       if (y(i)%n > 0) then
          jac_i(k:k+y(i)%n-1) = i
{{if USE_ALLOCATABLE}}
          jac_j(k:k+y(i)%n-1) = y(i)%i(1:y(i)%n)
          jac_val(k:k+y(i)%n-1) = y(i)%vmul * y(i)%v(1:y(i)%n)
{{else}}
          jac_j(k:k+y(i)%n-1) = imem_{{CHR}}(y(i)%j:y(i)%j+y(i)%n-1)
          jac_val(k:k+y(i)%n-1) = y(i)%vmul * vmem_{{CHR}}(y(i)%j:y(i)%j+y(i)%n-1)
{{endif}}
          k = k + y(i)%n
       end if
    end do
  end subroutine get_coo_jacobian_{{CHR}}

  subroutine get_csr_jacobian_{{CHR}}(y, jac_val, jac_indices, jac_indptr)
    implicit none
    type({{TYPE}}), dimension(:), intent(inout) :: y
    {{FTYPE}}, dimension(:), intent(out) :: jac_val
    integer, dimension(:), intent(out) :: jac_indices, jac_indptr

    integer :: i, k

    if (jac_product_mode) then
       call fatal_error('call to adjac_get_csr_jacobian when jacobian product mode is active')
    end if

    k = 1
    jac_indptr(1) = 1
    do i = 1, size(y,1)
       if (y(i)%n > 0) then
{{if USE_ALLOCATABLE}}
          jac_indices(k:k+y(i)%n-1) = y(i)%i(1:y(i)%n)
          jac_val(k:k+y(i)%n-1) = y(i)%vmul * y(i)%v(1:y(i)%n)
{{else}}
          jac_indices(k:k+y(i)%n-1) = imem_{{CHR}}(y(i)%j:y(i)%j+y(i)%n-1)
          jac_val(k:k+y(i)%n-1) = y(i)%vmul * vmem_{{CHR}}(y(i)%j:y(i)%j+y(i)%n-1)
{{endif}}
          k = k + y(i)%n
       end if
       jac_indptr(i+1) = k
    end do
  end subroutine get_csr_jacobian_{{CHR}}

  {{pure}} subroutine sum_taylor_{{CHR}}(alphap, betap, a, b, c)
    ! c := alpha*a + beta*b
    use iso_c_binding
    implicit none
    {{FTYPE}}, intent(in) :: alphap, betap
    type({{TYPE}}), intent(in) :: a, b
    type({{TYPE}}), intent(inout) :: c

    interface
       {{pure}} subroutine sparse_vector_sum_{{CHR}}(alpha, beta, na, nb, nc, ia, ib, ic, va, vb, vc) &
            bind(C,name="sparse_vector_sum_{{CHR}}")
         use iso_c_binding
         integer(kind=c_int), intent(in) :: na, nb, ia(*), ib(*)
         integer(kind=c_int), intent(inout) :: nc
         integer(kind=c_int), intent(out) :: ic(*)
         {{if TYPE == "adjac_double"}}
         real(kind=c_double), intent(in) :: alpha, beta, va(*), vb(*)
         real(kind=c_double), intent(out) :: vc(*)
         {{else}}
         complex(kind=c_double_complex), intent(in) :: alpha, beta, va(*), vb(*)
         complex(kind=c_double_complex), intent(out) :: vc(*)
         {{endif}}
       end subroutine sparse_vector_sum_{{CHR}}
    end interface

    if (jac_product_mode) then
       c%vmul = alphap * a%vmul + betap * b%vmul
    else
{{if USE_ALLOCATABLE}}
       call sparse_vector_sum_{{CHR}}(alphap*a%vmul, betap*b%vmul, a%n, b%n, c%n, &
            a%i, b%i, c%i, &
            a%v, b%v, c%v)
{{else}}
       call sparse_vector_sum_{{CHR}}(alphap*a%vmul, betap*b%vmul, a%n, b%n, c%n, &
            imem_{{CHR}}(a%j), imem_{{CHR}}(b%j), imem_{{CHR}}(c%j), &
            vmem_{{CHR}}(a%j), vmem_{{CHR}}(b%j), vmem_{{CHR}}(c%j))
{{endif}}
       c%vmul = 1
    end if
  end subroutine sum_taylor_{{CHR}}

  
  !--------------------------------------------------------------------------
  ! Overloaded operators
  !--------------------------------------------------------------------------

  !!
  !! assignment(=)
  !!

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} subroutine assign_{{CHR}}{{CHR2}}(x, y)
    implicit none
    type({{TYPE}}), intent(inout) :: x
    {{FTYPE2}}, intent(in) :: y
    call free_mem_{{CHR}}(x)
    x%value = y
    x%vmul = 0
  end subroutine assign_{{CHR}}{{CHR2}}
  {{endfor}}

  {{if TYPE == "adjac_double"}}
  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} subroutine assign_b{{CHR2}}(x, y)
    implicit none
    type(adjac_complex), intent(inout) :: x
    {{FTYPE2}}, intent(in) :: y
    x%re = dble(y)
    x%im = 0d0
  end subroutine assign_b{{CHR2}}
  {{endfor}}

  {{pure_elemental}} subroutine assign_bz(x, y)
    implicit none
    type(adjac_complex), intent(inout) :: x
    double complex, intent(in) :: y
    x%re = dble(y)
    x%im = aimag(y)
  end subroutine assign_bz

  {{pure_elemental}} subroutine assign_ba(x, y)
    implicit none
    type(adjac_complex), intent(inout) :: x
    type({{TYPE}}), intent(in) :: y
    x%re = y
    x%im = 0d0
  end subroutine assign_ba
  {{endif}}

  !!
  !! operator(+)
  !!

  ! X + Y = x + y + (x_j + y_j) dj

  {{pure_elemental}} function add_{{CHR}}{{CHR}}(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x, y
    type({{TYPE}}) :: z

    z%value = x%value + y%value
    call alloc_mem_{{CHR}}(z, x%n + y%n)
    call sum_taylor({{CAST}}(1d0), {{CAST}}(1d0), x, y, z)
  end function add_{{CHR}}{{CHR}}

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} function add_{{CHR}}{{CHR2}}(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    {{FTYPE2}}, intent(in) :: y
    type({{TYPE}}) :: z
    z%value = x%value + y
    z%vmul = x%vmul
    call link_mem_{{CHR}}(z, x)
  end function add_{{CHR}}{{CHR2}}

  {{pure_elemental}} function add_{{CHR2}}{{CHR}}(x, y) result(z)
    implicit none
    {{FTYPE2}}, intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type({{TYPE}}) :: z
    z = y + x
  end function add_{{CHR2}}{{CHR}}
  {{endfor}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function add_az(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x + dble(y)
    z%im = aimag(y)
  end function add_az

  {{pure_elemental}} function add_za(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) + y
    z%im = aimag(x)
  end function add_za

  {{pure_elemental}} function add_bb(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re + y%re
    z%im = x%im + y%im
  end function add_bb

  {{pure_elemental}} function add_bz(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re + dble(y)
    z%im = x%im + aimag(y)
  end function add_bz

  {{pure_elemental}} function add_zb(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) + y%re
    z%im = aimag(x) + y%im
  end function add_zb

  {{pure_elemental}} function add_ba(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re + y
    z%im = x%im
  end function add_ba

  {{pure_elemental}} function add_ab(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x + y%re
    z%im = y%im
  end function add_ab

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} function add_b{{CHR2}}(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    {{FTYPE2}}, intent(in) :: y
    type(adjac_complex) :: z
    z = x + dcmplx(y)
  end function add_b{{CHR2}}

  {{pure_elemental}} function add_{{CHR2}}b(x, y) result(z)
    implicit none
    {{FTYPE2}}, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) + y
  end function add_{{CHR2}}b
  {{endfor}}

  {{endif}}

  !!
  !! operator(+), unary
  !!

  {{pure_elemental}} function pos_{{CHR}}(x) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type({{TYPE}}) :: z
    z = x
  end function pos_{{CHR}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function pos_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    z = x
  end function pos_b
  {{endif}}

  !!
  !! operator(-)
  !!

  ! X - Y = x - y + (x_j - y_j) dj

  {{pure_elemental}} function sub_{{CHR}}{{CHR}}(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x, y
    type({{TYPE}}) :: z

    z%value = x%value - y%value
    call alloc_mem_{{CHR}}(z, x%n + y%n)
    call sum_taylor({{CAST}}(1d0), {{CAST}}(-1d0), x, y, z)
  end function sub_{{CHR}}{{CHR}}

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} function sub_{{CHR}}{{CHR2}}(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    {{FTYPE2}}, intent(in) :: y
    type({{TYPE}}) :: z
    z%value = x%value - y
    z%vmul = x%vmul
    call link_mem_{{CHR}}(z, x)
  end function sub_{{CHR}}{{CHR2}}

  {{pure_elemental}} function sub_{{CHR2}}{{CHR}}(x, y) result(z)
    implicit none
    {{FTYPE2}}, intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type({{TYPE}}) :: z
    z%value = x - y%value
    z%vmul = -y%vmul
    call link_mem_{{CHR}}(z, y)
  end function sub_{{CHR2}}{{CHR}}
  {{endfor}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function sub_az(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x - dble(y)
    z%im = -aimag(y)
  end function sub_az

  {{pure_elemental}} function sub_za(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) - y
    z%im = aimag(x)
  end function sub_za

  {{pure_elemental}} function sub_bb(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re - y%re
    z%im = x%im - y%im
  end function sub_bb

  {{pure_elemental}} function sub_bz(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re - dble(y)
    z%im = x%im - aimag(y)
  end function sub_bz

  {{pure_elemental}} function sub_zb(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) - y%re
    z%im = aimag(x) - y%im
  end function sub_zb

  {{pure_elemental}} function sub_ba(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re - y
    z%im = x%im
  end function sub_ba

  {{pure_elemental}} function sub_ab(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x - y%re
    z%im = -y%im
  end function sub_ab

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} function sub_b{{CHR2}}(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    {{FTYPE2}}, intent(in) :: y
    type(adjac_complex) :: z
    z = x - dcmplx(y)
  end function sub_b{{CHR2}}

  {{pure_elemental}} function sub_{{CHR2}}b(x, y) result(z)
    implicit none
    {{FTYPE2}}, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) - y
  end function sub_{{CHR2}}b
  {{endfor}}
  {{endif}}

  !!
  !! operator(-), unary
  !!

  {{pure_elemental}} function neg_{{CHR}}(x) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type({{TYPE}}) :: z
    z = 0d0 - x
  end function neg_{{CHR}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function neg_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    z = (0d0,0d0) - x
  end function neg_b
  {{endif}}

  !!
  !! operator(*)
  !!

  ! X*Y = x*y + (x y_j + y x_j) dj

  {{pure_elemental}} function mul_{{CHR}}{{CHR}}(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x, y
    type({{TYPE}}) :: z

    z%value = x%value * y%value
    call alloc_mem_{{CHR}}(z, x%n + y%n)
    call sum_taylor(y%value, x%value, x, y, z)
  end function mul_{{CHR}}{{CHR}}

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} function mul_{{CHR}}{{CHR2}}(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    {{FTYPE2}}, intent(in) :: y
    type({{TYPE}}) :: z
    if (y == 0) then
       z%value = 0
       z%vmul = 0
    else
       z%value = x%value * y
       z%vmul = x%vmul * y
       call link_mem_{{CHR}}(z, x)
    end if
  end function mul_{{CHR}}{{CHR2}}

  {{pure_elemental}} function mul_{{CHR2}}{{CHR}}(x, y) result(z)
    implicit none
    {{FTYPE2}}, intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type({{TYPE}}) :: z
    z = y * x
  end function mul_{{CHR2}}{{CHR}}
  {{endfor}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function mul_az(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x * dble(y)
    z%im = x * aimag(y)
  end function mul_az

  {{pure_elemental}} function mul_za(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) * y
    z%im = aimag(x) * y
  end function mul_za

  {{pure_elemental}} function mul_bb(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re * y%re - x%im * y%im
    z%im = x%re * y%im + x%im * y%re
  end function mul_bb

  {{pure_elemental}} function mul_bz(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re * dble(y) - x%im * aimag(y)
    z%im = x%re * aimag(y) + x%im * dble(y)
  end function mul_bz

  {{pure_elemental}} function mul_zb(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) * y%re - aimag(x) * y%im
    z%im = dble(x) * y%im + aimag(x) * y%re
  end function mul_zb

  {{pure_elemental}} function mul_ba(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re * y
    z%im = x%im * y
  end function mul_ba

  {{pure_elemental}} function mul_ab(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x * y%re
    z%im = x * y%im
  end function mul_ab

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} function mul_b{{CHR2}}(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    {{FTYPE2}}, intent(in) :: y
    type(adjac_complex) :: z
    z = x * dcmplx(y)
  end function mul_b{{CHR2}}

  {{pure_elemental}} function mul_{{CHR2}}b(x, y) result(z)
    implicit none
    {{FTYPE2}}, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) * y
  end function mul_{{CHR2}}b
  {{endfor}}
  {{endif}}

  !!
  !! operator(/)
  !!

  ! X/Y = x/y + (x_j/y - x y_j/y**2) dj

  {{pure_elemental}} function div_{{CHR}}{{CHR}}(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x, y
    type({{TYPE}}) :: z
    z%value = x%value / y%value
    call alloc_mem_{{CHR}}(z, x%n + y%n)
    call sum_taylor(1d0/y%value, -x%value/(y%value**2), x, y, z)
  end function div_{{CHR}}{{CHR}}

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} function div_{{CHR}}{{CHR2}}(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    {{FTYPE2}}, intent(in) :: y
    type({{TYPE}}) :: z
    z = (1d0 / y) * x
  end function div_{{CHR}}{{CHR2}}

  {{pure_elemental}} function div_{{CHR2}}{{CHR}}(x, y) result(z)
    implicit none
    {{FTYPE2}}, intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type({{TYPE}}) :: z
    z = (-x / (y%value**2)) * y
    z%value = x / y%value
  end function div_{{CHR2}}{{CHR}}
  {{endfor}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function div_az(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z = x * conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
  end function div_az

  {{pure_elemental}} function div_za(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) / y
    z%im = aimag(x) / y
  end function div_za

  {{pure_elemental}} function div_bb(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = x * conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
  end function div_bb

  {{pure_elemental}} function div_bz(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z = x * conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
  end function div_bz

  {{pure_elemental}} function div_zb(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = x * conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
  end function div_zb

  {{pure_elemental}} function div_ba(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type({{TYPE}}), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re / y
    z%im = x%im / y
  end function div_ba

  {{pure_elemental}} function div_ab(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = x * conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
  end function div_ab

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} function div_b{{CHR2}}(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    {{FTYPE2}}, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re / y
    z%im = x%im / y
  end function div_b{{CHR2}}

  {{pure_elemental}} function div_{{CHR2}}b(x, y) result(z)
    implicit none
    {{FTYPE2}}, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) / y
  end function div_{{CHR2}}b
  {{endfor}}
  {{endif}}

  !!
  !! operator(**)
  !!

  {{for FTYPE2, CHR2 in FTYPES2}}
  {{pure_elemental}} function pow_{{CHR}}{{CHR2}}(x, y) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    {{FTYPE2}}, intent(in) :: y
    type({{TYPE}}) :: z
    z = exp(y * log(x))
  end function pow_{{CHR}}{{CHR2}}
  {{endfor}}

  !!
  !! matmul
  !!

{{def matmulcode}}
    integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do
{{enddef}}

  function matmul_{{CHR}}{{CHR}}(x, y) result(z)
    implicit none
    type({{TYPE}}), dimension(:,:), intent(in) :: x, y
    type({{TYPE}}), dimension(size(x,1),size(y,2)) :: z
    {{matmulcode}}
  end function matmul_{{CHR}}{{CHR}}

  {{for FTYPE2, CHR2 in FTYPES2}}
  function matmul_{{CHR}}{{CHR2}}(x, y) result(z)
    implicit none
    type({{TYPE}}), dimension(:,:), intent(in) :: x
    {{FTYPE2}}, dimension(:,:), intent(in) :: y
    type({{TYPE}}), dimension(size(x,1),size(y,2)) :: z
    {{matmulcode}}
  end function matmul_{{CHR}}{{CHR2}}

  function matmul_{{CHR2}}{{CHR}}(x, y) result(z)
    implicit none
    {{FTYPE2}}, dimension(:,:), intent(in) :: x
    type({{TYPE}}), dimension(:,:), intent(in) :: y
    type({{TYPE}}), dimension(size(x,1),size(y,2)) :: z
    {{matmulcode}}
  end function matmul_{{CHR2}}{{CHR}}
  {{endfor}}

  {{if TYPE == "adjac_double"}}
  function matmul_bb(x, y) result(z)
    implicit none
    type(adjac_complex), dimension(:,:), intent(in) :: x, y
    type(adjac_complex), dimension(size(x,1),size(y,2)) :: z
    {{matmulcode}}
  end function matmul_bb

  function matmul_bz(x, y) result(z)
    implicit none
    type(adjac_complex), dimension(:,:), intent(in) :: x
    double complex, dimension(:,:), intent(in) :: y
    type(adjac_complex), dimension(size(x,1),size(y,2)) :: z
    {{matmulcode}}
  end function matmul_bz

  function matmul_zb(x, y) result(z)
    implicit none
    double complex, dimension(:,:), intent(in) :: x
    type(adjac_complex), dimension(:,:), intent(in) :: y
    type(adjac_complex), dimension(size(x,1),size(y,2)) :: z
    {{matmulcode}}
  end function matmul_zb
  {{endif}}

  !!
  !! dble
  !!

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function dble_a(x) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_double) :: z
    z = x
  end function dble_a

  {{pure_elemental}} function dble_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_double) :: z
    z = x%re
  end function dble_b
  {{endif}}

  !!
  !! aimag
  !!

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function aimag_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_double) :: z
    z = x%im
  end function aimag_b
  {{endif}}

  !!
  !! conjg
  !!

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function conjg_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    z%re = x%re
    z%im = -x%im
  end function conjg_b
  {{endif}}

  !!
  !! exp
  !!

  {{pure_elemental}} function exp_{{CHR}}(x) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type({{TYPE}}) :: z
    {{FTYPE}} :: v, dv
    v = exp(x%value)
    dv = v
    z = dv*x
    z%value = v
  end function exp_{{CHR}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function exp_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    double complex :: v, dv
    v = exp(dcmplx(x%re%value, x%im%value))
    dv = v
    z = dv*x
    z%re%value = dble(v)
    z%im%value = aimag(v)
  end function exp_b
  {{endif}}

  !!
  !! sin
  !!

  {{pure_elemental}} function sin_{{CHR}}(x) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type({{TYPE}}) :: z
    {{FTYPE}} :: v, dv
    v = sin(x%value)
    dv = cos(x%value)
    z = dv*x
    z%value = v
  end function sin_{{CHR}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function sin_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    double complex :: v, dv
    v = sin(dcmplx(x%re%value, x%im%value))
    dv = cos(dcmplx(x%re%value, x%im%value))
    z = dv*x
    z%re%value = dble(v)
    z%im%value = aimag(v)
  end function sin_b
  {{endif}}

  !!
  !! cos
  !!

  {{pure_elemental}} function cos_{{CHR}}(x) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type({{TYPE}}) :: z
    {{FTYPE}} :: v, dv
    v = cos(x%value)
    dv = -sin(x%value)
    z = dv*x
    z%value = v
  end function cos_{{CHR}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function cos_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    double complex :: v, dv
    v = cos(dcmplx(x%re%value, x%im%value))
    dv = -sin(dcmplx(x%re%value, x%im%value))
    z = dv*x
    z%re%value = dble(v)
    z%im%value = aimag(v)
  end function cos_b
  {{endif}}

  !!
  !! log
  !!

  {{pure_elemental}} function log_{{CHR}}(x) result(z)
    implicit none
    type({{TYPE}}), intent(in) :: x
    type({{TYPE}}) :: z
    {{FTYPE}} :: v, dv
    v = log(x%value)
    dv = 1d0/x%value
    z = dv*x
    z%value = v
  end function log_{{CHR}}

  {{if TYPE == "adjac_double"}}
  {{pure_elemental}} function log_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    double complex :: v, dv
    v = log(dcmplx(x%re%value, x%im%value))
    dv = 1d0/dcmplx(x%re%value, x%im%value)
    z = dv*x
    z%re%value = dble(v)
    z%im%value = aimag(v)
  end function log_b
  {{endif}}
{{endfor}}

{{if not USE_ALLOCATABLE}}
  {{elemental_versions('assign', 'assign', ops='ai ad bi bd bz ba qi qd qz'.split())}}
  {{elemental_versions('add', 'binop')}}
  {{elemental_versions('sub', 'binop')}}
  {{elemental_versions('mul', 'binop')}}
  {{elemental_versions('div', 'binop')}}
  {{elemental_versions('pow', 'binop', ops=['ai', 'ad', 'qi', 'qd', 'qz'])}}
  {{elemental_versions('dble', 'unop', ops=['a', 'b'])}}
  {{elemental_versions('aimag', 'unop', ops=['b'])}}
  {{elemental_versions('conjg', 'unop', ops=['b'])}}
  {{elemental_versions('neg', 'unop', ops=['a', 'b', 'q'])}}
  {{elemental_versions('pos', 'unop', ops=['a', 'b', 'q'])}}
  {{elemental_versions('exp', 'unop', ops=['a', 'b', 'q'])}}
  {{elemental_versions('sin', 'unop', ops=['a', 'b', 'q'])}}
  {{elemental_versions('cos', 'unop', ops=['a', 'b', 'q'])}}
  {{elemental_versions('log', 'unop', ops=['a', 'b', 'q'])}}
{{endif}}

end module adjac
